// SQLite Prisma schema for image storage
// Run migrations locally: npx prisma migrate dev --name init
// Generate client only: npx prisma generate

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Image {
  id             String     @id @default(uuid())
  kind           ImageKind
  url            String // public URL path we expose (virtual; may be /images/:id)
  mimeType       String
  width          Int?
  height         Int?
  sizeBytes      Int
  originalName   String?
  // generation metadata
  prompt          String?
  expandedPrompt  String?
  // Keep canonical buckets via enum; DB stores mapped string values
  size            ImageSize?
  seed            String?
  baseImageId     String?
  hasMask         Boolean? @default(false)
  provider        String?
  // Session grouping
  sessionId       String?   // Links images to a session for grouping
  session         GenerationSession? @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  blob ImageBlob?

  @@index([createdAt])
  @@index([kind, createdAt])
  @@index([baseImageId])
  @@index([sessionId])
}

enum ImageKind {
  UPLOAD_BASE
  GENERATED
}

// Mapped enum so DB stores human-friendly labels while Prisma exposes TS-safe members
enum ImageSize {
  S512x512   @map("512x512")
  S768x768   @map("768x768")
  S1024x1024 @map("1024x1024")
}

// New: Dynamic image generators that can be created and managed via API
model ImageGenerator {
  id          String   @id @default(uuid())
  slug        String   @unique
  name        String
  description String?
  style       String?   // e.g., "turn-toon", "puppetray", or custom style label
  config      Json?     // arbitrary config for prompts, defaults, etc.
  theme       Json?     // styling data (tailwind classes, colors) for on-demand theming
  isActive    Boolean   @default(true)

  // Ownership
  createdById String?
  createdBy   User?     @relation(fields: [createdById], references: [id], onDelete: SetNull)

  // Related sessions
  sessions    GenerationSession[]

  // New: back relation for questionnaires
  questionnaires GeneratorQuestionnaire[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([createdById])
  @@index([isActive])
}

// Image generation sessions for grouping related images
model GenerationSession {
  id          String   @id @default(uuid())
  name        String   // User-friendly name for the session
  description String?  // Optional description
  generator   String   // Which generator was used (legacy string; keep for compatibility)
  
  // New optional relation to dynamic ImageGenerator
  generatorId String?
  generatorRef ImageGenerator? @relation(fields: [generatorId], references: [id], onDelete: SetNull)
  
  // Auth relationship
  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id], onDelete: Cascade)
  
  // Related images
  images      Image[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([createdById])
  @@index([generator])
  @@index([generatorId])
  @@index([createdAt])
}

// Store binary data separately to keep Image table lean
model ImageBlob {
  id   String @id
  data Bytes

  image Image @relation(fields: [id], references: [id], onDelete: Cascade)
}

// Email signup for marketing and updates
model EmailSignup {
  id          String   @id @default(uuid())
  email       String   @unique
  preferences Json     // Store email preferences as JSON
  source      String   // Track where the signup came from (e.g., 'generation_modal', 'footer', etc.)
  ipAddress   String?
  userAgent   String?
  verified    Boolean  @default(false)
  active      Boolean  @default(true)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([createdAt])
  @@index([source])
}

// Session codes created by admins for users to access generation features
model SessionCode {
  id              String   @id @default(uuid())
  code            String   @unique // 6-9 letter code
  name            String?  // Optional name/description for the session
  maxGenerations  Int      @default(10) // Number of generations allowed
  usedGenerations Int      @default(0)  // Number of generations used
  isActive        Boolean  @default(true)
  expiresAt       DateTime? // Optional expiration date
  
  createdById     String?  // User ID of admin who created it
  createdBy       User?    @relation(fields: [createdById], references: [id], onDelete: SetNull)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([code])
  @@index([isActive])
  @@index([createdAt])
}

// Auth.js required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id               String    @id @default(cuid())
  name             String?
  email            String?   @unique
  emailVerified    DateTime?
  image            String?
  // New: credentials-based auth support
  passwordHash     String?
  
  accounts         Account[]
  sessions         Session[]
  sessionCodes     SessionCode[] // Session codes created by this admin
  generationSessions GenerationSession[] // Generation sessions created by this user
  // New: generators created by this user
  generators       ImageGenerator[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// New model for per-generator question schemas and entries
model GeneratorQuestionnaire {
  id          String   @id @default(uuid())
  slug        String   @unique
  schema      Json     // JSON schema for the questionnaire

  // Optional: relations to ImageGenerator if needed
  generatorId String?
  generator   ImageGenerator? @relation(fields: [generatorId], references: [id], onDelete: SetNull)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
