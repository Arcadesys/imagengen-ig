// SQLite Prisma schema for image storage
// Run migrations locally: npx prisma migrate dev --name init
// Generate client only: npx prisma generate

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Image {
  id             String     @id @default(uuid())
  kind           ImageKind
  url            String // public URL path we expose (virtual; may be /images/:id)
  mimeType       String
  width          Int?
  height         Int?
  sizeBytes      Int
  originalName   String?
  // generation metadata
  prompt          String?
  expandedPrompt  String?
  // Keep canonical buckets via enum; DB stores mapped string values
  size            ImageSize?
  seed            String?
  baseImageId     String?
  hasMask         Boolean? @default(false)
  provider        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  blob ImageBlob?

  @@index([createdAt])
  @@index([kind, createdAt])
  @@index([baseImageId])
}

enum ImageKind {
  UPLOAD_BASE
  GENERATED
}

// Mapped enum so DB stores human-friendly labels while Prisma exposes TS-safe members
enum ImageSize {
  S512x512   @map("512x512")
  S768x768   @map("768x768")
  S1024x1024 @map("1024x1024")
}

// Store binary data separately to keep Image table lean
model ImageBlob {
  id   String @id
  data Bytes

  image Image @relation(fields: [id], references: [id], onDelete: Cascade)
}

// Email signup for marketing and updates
model EmailSignup {
  id          String   @id @default(uuid())
  email       String   @unique
  preferences Json     // Store email preferences as JSON
  source      String   // Track where the signup came from (e.g., 'generation_modal', 'footer', etc.)
  ipAddress   String?
  userAgent   String?
  verified    Boolean  @default(false)
  active      Boolean  @default(true)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([email])
  @@index([createdAt])
  @@index([source])
}

// Auth.js required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
